%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\extraspacing{\vspace{5mm} \noindent}

\def\best{\mathit{best}}
\def\size{\mathit{size}}

\newboolean{solver}\setboolean{solver}{true}
%\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Tutorial 9}
Prepared by Yufei Tao \\

\begin{center}
    \uline{Classroom Discussion}
\end{center}

\extraspacing {\bf Problem 1.} Consider the following schedule:

\begin{center}
    \begin{tabular}{c|c}
        no & instruction \\
        \hline
        1 & $T_1: \ttt{READ}(X)$ \\
        2 & $T_1: X = X + 1$ \\
        3 & $T_1: \ttt{WRITE}(X)$ \\
        4 & $T_2: \ttt{READ}(X)$ \\
        5 & $T_2: Y = X + 1$ \\
        6 & $T_2: \ttt{WRITE}(Y)$ \\
        7 & $T_3: \ttt{READ}(Y)$ \\
        8 & $T_3: Z = Y + 1$ \\
        9 & $T_3: \ttt{WRITE}(Z)$
    \end{tabular}
\end{center}

(1) Assume that the values of $X$, $Y$, and $Z$ are all 0 on disk initially. What are their (disk) values after instruction 9?

(2) Suppose that $T_1$ aborts right after instruction 9. A rollback process then kicks in. What are the values of $X$, $Y$, and $Z$ on disk after the process? Which of $T_2$ and $T_3$ are still running at that time?

(3) Which of the three $\ttt{READ}$ operations are dirty?

(4) Suppose that everything runs fine and the three transactions are ready to commit. What are the possible commit orders so that the overall schedule is recoverable?

\begin{sol}
\extraspacing {\bf Solution.} (1): $X = 1, Y = 2, Z = 3$.

\vgap

(2) $X = Y = Z = 0$. Neither $T_2$ nor $T_3$ is running because they are both forced to abort.

\vgap

(3) Instructions 4 and 7.

\vgap

(4) Since $T_2$ reads a value written by $T_1$, $T_2$ must commit after $T_1$. Likewise, since $T_3$ reads a value written by $T_2$, $T_3$ must commit after $T_2$. Therefore, the only possible commit order is $T_1, T_2, T_3$.
\end{sol}

\extraspacing {\bf Problem 2.} Consider three transactions:

$T_1: \ttt{READ}(A); \ttt{READ}(B); A = A + 100; B = 2B; \ttt{WRITE}(B); \ttt{WRITE}(A); \ttt{COMMIT}$

$T_2: \ttt{READ}(B); B = B + 50; \ttt{WRITE}(B); \ttt{READ}(C); C = B + C; \ttt{WRITE}(C); \ttt{COMMIT}$

$T_3: \ttt{READ}(C); C = 3C; \ttt{WRITE}(C); \ttt{COMMIT}$

The following are two schedules for executing these transactions (showing only the I/O and commit instructions):

\begin{center}
    \begin{tabular}{c|c}
        schedule 1 & schedule 2 \\
        \hline
        $T_1: \ttt{READ}(A)$ & $T_1: \ttt{READ}(A)$ \\
        $T_1: \ttt{READ}(B)$ & $T_3: \ttt{READ}(C)$ \\
        $T_1: \ttt{WRITE}(B)$ & $T_1: \ttt{READ}(B)$ \\
        $T_1: \ttt{WRITE}(A)$ & $T_1: \ttt{WRITE}(B)$ \\
        $T_2: \ttt{READ}(B)$ & $T_2: \ttt{READ}(B)$ \\
        $T_2: \ttt{WRITE}(B)$ & $T_2: \ttt{WRITE}(B)$  \\
        $T_2: \ttt{READ}(C)$ & $T_3: \ttt{WRITE}(C)$  \\
        $T_2: \ttt{WRITE}(C)$ & $T_2: \ttt{READ}(C)$  \\
        $T_3: \ttt{READ}(C)$ &  $T_1: \ttt{WRITE}(A)$ \\
        $T_3: \ttt{WRITE}(C)$ & $T_2: \ttt{WRITE}(C)$
    \end{tabular}
\end{center}

(1) Are the two schedules equivalent?

(2) Is schedule 2 serializable?

\begin{sol}
    \extraspacing {\bf Solution.} (i) Two schedules are equivalent if they always leave the database in the same state. Suppose that the disk values of $A$, $B$, and $C$ are $a_0, b_0$, and $c_0$, respectively. After schedule 1, their disk values become $a_0 + 100$, $2b_0 + 50$, and $3(2b_0 + 50 + c_0)$, respectively. After schedule 2, their disk values become $a_0 + 100, 2b_0 + 50$, and $3c_0 + 2b_0 + 50$, respectively. As $3(2b_0 + 50 + c_0)$ is not always equivalent to $3c_0 + 2b_0 + 50$, the two schedules are not equivalent.

    \vgap

    (2) Yes: schedule 2 is equivalent to the serial schedule $T_1, T_3, T_2$.
\end{sol}

\extraspacing {\bf Problem 3.}


\end{document}
