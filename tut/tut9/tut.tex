%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\extraspacing{\vspace{5mm} \noindent}

\def\best{\mathit{best}}
\def\size{\mathit{size}}

\newboolean{solver}\setboolean{solver}{true}
%\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Tutorial 9}
Prepared by Yufei Tao \\

\begin{center}
    \uline{Classroom Discussion}
\end{center}

\extraspacing {\bf Problem 1.} Consider the following schedule:

\begin{center}
    \begin{tabular}{c|c}
        no & instruction \\
        \hline
        1 & $T_1: \ttt{READ}(X)$ \\
        2 & $T_1: X = X + 1$ \\
        3 & $T_1: \ttt{WRITE}(X)$ \\
        4 & $T_2: \ttt{READ}(X)$ \\
        5 & $T_2: Y = X + 1$ \\
        6 & $T_2: \ttt{WRITE}(Y)$ \\
        7 & $T_3: \ttt{READ}(Y)$ \\
        8 & $T_3: Z = Y + 1$ \\
        9 & $T_3: \ttt{WRITE}(Z)$
    \end{tabular}
\end{center}

(1) Assume that the values of $X$, $Y$, and $Z$ are all 0 on disk initially. What are their (disk) values after instruction 9?

(2) Suppose that $T_1$ aborts right after instruction 9. A rollback process then kicks in. What are the values of $X$, $Y$, and $Z$ on disk after the process? Which of $T_2$ and $T_3$ are still running at that time?

(3) Which of the three $\ttt{READ}$ operations are dirty?

(4) Suppose that everything runs fine and the three transactions are ready to commit. What are the possible commit orders so that the overall schedule is recoverable?

\begin{sol}
\extraspacing {\bf Solution.} (1): $X = 1, Y = 2, Z = 3$.

\vgap

(2) $X = Y = Z = 0$. Neither $T_2$ nor $T_3$ is running because they are both forced to abort.

\vgap

(3) Instructions 4 and 7.

\vgap

(4) Since $T_2$ reads a value written by $T_1$, $T_2$ must commit after $T_1$. Likewise, since $T_3$ reads a value written by $T_2$, $T_3$ must commit after $T_2$. Therefore, the only possible commit order is $T_1, T_2, T_3$.
\end{sol}

\extraspacing {\bf Problem 2.} Consider three transactions:

$T_1: \ttt{READ}(A); \ttt{READ}(B); A = A + 100; B = 2B; \ttt{WRITE}(B); \ttt{WRITE}(A); \ttt{COMMIT}$

$T_2: \ttt{READ}(B); B = B + 50; \ttt{WRITE}(B); \ttt{READ}(C); C = B + C; \ttt{WRITE}(C); \ttt{COMMIT}$

$T_3: \ttt{READ}(C); C = 3C; \ttt{WRITE}(C); \ttt{COMMIT}$

The following are two schedules for executing these transactions (showing only the I/O and commit instructions):

\begin{center}
    \begin{tabular}{c|c}
        schedule 1 & schedule 2 \\
        \hline
        $T_1: \ttt{READ}(A)$ & $T_1: \ttt{READ}(A)$ \\
        $T_1: \ttt{READ}(B)$ & $T_3: \ttt{READ}(C)$ \\
        $T_1: \ttt{WRITE}(B)$ & $T_1: \ttt{READ}(B)$ \\
        $T_1: \ttt{WRITE}(A)$ & $T_1: \ttt{WRITE}(B)$ \\
        $T_2: \ttt{READ}(B)$ & $T_2: \ttt{READ}(B)$ \\
        $T_2: \ttt{WRITE}(B)$ & $T_2: \ttt{WRITE}(B)$  \\
        $T_2: \ttt{READ}(C)$ & $T_3: \ttt{WRITE}(C)$  \\
        $T_2: \ttt{WRITE}(C)$ & $T_2: \ttt{READ}(C)$  \\
        $T_3: \ttt{READ}(C)$ &  $T_1: \ttt{WRITE}(A)$ \\
        $T_3: \ttt{WRITE}(C)$ & $T_2: \ttt{WRITE}(C)$
    \end{tabular}
\end{center}

(1) Are the two schedules equivalent?

(2) Is schedule 2 serializable?

\begin{sol}
    \extraspacing {\bf Solution.} (i) Two schedules are equivalent if they always leave the database in the same state. Suppose that the disk values of $A$, $B$, and $C$ are $a_0, b_0$, and $c_0$, respectively. After schedule 1, their disk values become $a_0 + 100$, $2b_0 + 50$, and $3(2b_0 + 50 + c_0)$, respectively. After schedule 2, their disk values become $a_0 + 100, 2b_0 + 50$, and $3c_0 + 2b_0 + 50$, respectively. As $3(2b_0 + 50 + c_0)$ is not always equivalent to $3c_0 + 2b_0 + 50$, the two schedules are not equivalent.

    \vgap

    (2) Yes: schedule 2 is equivalent to the serial schedule $T_1, T_3, T_2$.
\end{sol}

\extraspacing {\bf Problem 3.} We have a relation \ttt{ACC}(\ttt{id}, \ttt{balance}), which has only 1 tuple $(1, 100)$. Consider the following concurrent schedule:

\begin{center}
    \begin{tabular}{c|c|c}
        & $T_1$ & $T_2$ \\
        \hline
        1 & \ttt{select sum}(\ttt{balance}) \ttt{from ACC} & \\
        2 && \ttt{update ACC set balance} = \ttt{balance} + 100 \\
        3 & \ttt{select sum}(\ttt{balance}) \ttt{from ACC} & \\
        4 && \ttt{insert into ACC values} (2, 200) \\
        5 & \ttt{select sum}(\ttt{balance}) \ttt{from ACC} & \\
    \end{tabular}
\end{center}

%(1) What is the result of the query in Instruction 1?

%\vgap

(1) Suppose that the database executes the query in instruction 3 on \ttt{ACC} after the relation has been updated by Instruction 2. What is its result? Among non-serializability, phantom, non-repeatable read, and dirty read, what anomalies does this incur?

\vgap

(2) Suppose that the database executes the query in instruction 5 on \ttt{ACC} after the relation has been updated by Instructions 2 and 4. What is its result? Among non-serializability, phantom, non-repeatable read, and dirty read, what anomalies does this incur?

\vgap

(3) Can the situations in (1) and (2) occur if $T_1$ and $T_2$ are run at the ``read committed'' isolation level? What if $T_2$ commits right after Instruction 2 (without executing Instruction 4)?

\vgap

(4) Suppose that both $T_1$ and $T_2$ are both at the ``serializable'' isolation level. The above schedule is actually allowed by PostgreSQL. However, all three queries of $T_1$ will return the same result 100. Does this violate serializability? Why?

\begin{sol}
    \extraspacing {\bf Solution.} (1) The query returns 200. There are three anomalies here: non-serializability, non-repeatable read, and dirty read (because $T_2$ has not committed).

    \vgap

    (2) The query returns 400. There are two anomalies here: non-serializability, phantom, and dirty read.

    \vgap

    (3) No because ``read committed'' does not allow dirty reads. However, if $T_2$ commits rights after Instruction 2, then the answer is yes.

    \vgap

    (4) It does not! The execution of PostgreSQL is equivalent to the serial schedule $T_1, T_2$.
\end{sol}


\end{document}
