%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\dom{\prec}
\def\T{\mathcal{T}}

\newboolean{solver}\setboolean{solver}{true}
%\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CZ4031: Tutorial 6}
%Prepared by Yufei Tao \\


\extraspacing {\bf Problem 1.} Suppose that we have three sets of integers, denoted as $S_1, S_2$, and $S_3$, respectively. Each set is sorted and given to you in a file. Assume that each disk block can hold 2 integers, and the memory has 4 blocks. The content of $S_1, S_2$, and $S_3$ is shown below.

\vgap

\noindent $S_1:$ $\uline{[1, 10]}, \uline{[20, 30]}, \uline{[40, 50]}$ \\
$S_2:$ $\uline{[5, 35]}, \uline{[37, 38]}$ \\
$S_3:$ $\uline{[45, 60]}$

\vgap

\noindent The notation $\uline{[x, y]}$ represents a block holding integers $x$ and $y$. It is clear that $S_1$, $S_2$, and $S_3$ occupy 3, 2, and 1 block, respectively.

\vgap

Demonstrate how to merge $S_1$, $S_2$, and $S_3$ into one sorted file using the merging algorithm taught in the class. What is the I/O cost of the algorithm?

\begin{sol}
\extraspacing {\bf Solution.} The merging algorithm allocates (i) one memory block as the input buffer to read $S_i$, for each $i \in [1, 3]$, and (ii) one memory block as the output buffer. In the beginning, the algorithm loads the first block of each input file into memory, whose content is shown below:

\begin{center}
    Memory: $\uline{[1, 10]}, \uline{[5, 35]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$
\end{center}

\noindent As long as no input buffer is empty, the algorithm moves the smallest integer in the 3 input buffers to the output buffer. This yields:

\begin{center}
    Memory: $\uline{[\hspace{5mm}, 10]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[1, 5]}$
\end{center}

\noindent Now the output buffer is full and thus flushed to the disk:

\begin{center}
    Memory: $\uline{[\hspace{5mm}, 10]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}$ \\
\end{center}

\noindent Moving the next smallest element in the input buffers to the output buffer yields:

\begin{center}
    Memory: $\uline{[\hspace{10mm}]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[10, \hspace{5mm}]}$
\end{center}

\noindent The first input buffer is full, prompting the algorithm to read the next page of $S_1$:

\begin{center}
    Memory: $\uline{[20, 30]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[10, \hspace{5mm}]}$
\end{center}

\noindent The next few steps of the algorithm are straightforward:

\begin{center}
    Memory: $\uline{[\hspace{5mm}, 30]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[10, 20]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[\hspace{5mm}, 30]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[\hspace{10mm}]}, \uline{[\hspace{5mm}, 35]}, \uline{[45, 60]}, \uline{[30, \hspace{5mm}]}$
\end{center}

\noindent Reading the next page of $S_1$ gives:

\begin{center}
    Memory: $\uline{[40, 50]}, \uline{[\hspace{10mm}]}, \uline{[45, 60]}, \uline{[30, 35]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[40, 50]}, \uline{[\hspace{10mm}]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}, \uline{[30, 35]}$ \\
\end{center}

\noindent Now we reading the next page of $S_2$:

\begin{center}
    Memory: $\uline{[40, 50]}, \uline{[37, 38]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}, \uline{[30, 35]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[40, 50]}, \uline{[\hspace{10mm}]}, \uline{[45, 60]}, \uline{[37, 38]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[40, 50]}, \uline{[\hspace{10mm}]}, \uline{[45, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}, \uline{[30, 35]}, \uline{[37, 38]}$ \\
\end{center}

\noindent No need to replenish the input buffer of $S_2$ because this file has been exhausted. The remaining execution should be straightforward:

\begin{center}
    Memory: $\uline{[\hspace{5mm}, 50]}, \uline{[\hspace{10mm}]}, \uline{[\hspace{5mm}, 60]}, \uline{[40, 45]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[\hspace{5mm}, 50]}, \uline{[\hspace{10mm}]}, \uline{[\hspace{5mm}, 60]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}, \uline{[30, 35]}, \uline{[37, 38]}, \uline{[40, 45]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[\hspace{10mm}]}, \uline{[\hspace{10mm}]}, \uline{[\hspace{10mm}]}, \uline{[50, 60]}$ \\
    $\Rightarrow$ \\
    Memory: $\uline{[\hspace{10mm}]}, \uline{[\hspace{10mm}]}, \uline{[\hspace{10mm}]}, \uline{[\hspace{10mm}]}$ \\
    Output file on disk: $\uline{[1, 5]}, \uline{[10, 20]}, \uline{[30, 35]}, \uline{[37, 38]}, \uline{[40, 45]}, \uline{[50, 60]}$
\end{center}

\end{sol}



\end{document}
