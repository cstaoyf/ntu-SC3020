%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\extraspacing{\vspace{5mm} \noindent}

\def\best{\mathit{best}}
\def\size{\mathit{size}}

\newboolean{solver}\setboolean{solver}{true}
%\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Tutorial 10}
Prepared by Yufei Tao \\

\begin{center}
    \uline{Classroom Discussion}
\end{center}

\extraspacing {\bf Problem 1.} Consider the following schedule:

\begin{center}
\begin{tabular}{c|c|c|c|c|c}
    & $T_1$ & $T_2$ & $T_3$ & $T_4$ & $T_5$ \\
    \hline
    1 & READ(A)      &              &              &              &\\
    2 &              & READ(B)      &              &              &\\
    3 &              &              & WRITE(A)     &              &\\
    4 &              &              &              & READ(B)      &\\
    5 & WRITE(C)     &              &              &              &\\
    6 &              &              & READ(C)      &              &\\
    7 &              & WRITE(C)     &              &              &\\
    8 &              &              &              & WRITE(B)     &\\
    9 &              &              &              &              & WRITE (C) \\
    10 & COMMIT       &              &              &              &\\
    11 &              & COMMIT       &              &             & \\
    12 &              &              & COMMIT       &             & \\
    13 &              &              &              & COMMIT      & \\
    14 &              &              &              &             & COMMIT
\end{tabular}
\end{center}

Find all the serial schedules that are conflict-equivalent to the above schedule.

\vgap

Note: Two schedules are {\em conflict equivalent} if one can be transformed into the other by swapping non-conflicting operations.

\begin{sol}
\extraspacing {\bf Solution.} The precedence graph of the schedule is:
    \begin{center}
        \includegraphics[height=45mm]{./artwork/p-graph}
    \end{center}

To work out a conflict-equivalent serial schedule, first note:
\myitems{
    \item $T_1$ must be precede all other transactions;
    \item $T_3$ must be precede all other transactions but $T_1$;
    \item $T_2$ must be precede all other transactions but $T_1$ and $T_2$.
}
Therefore, there are only two possible conflict-equivalent serial schedules: $T_1, T_3, T_2, T_4, T_5$ and $T_1, T_3, T_2, T_5, T_4$.

\end{sol}

\extraspacing {\bf Problem 2.} Consider the following three transactions.

\begin{center}
    \begin{tabular}{c|c|c}
    $T_1$ & $T_2$ & $T_3$ \\
    \hline
    U-LOCK(A) & S-LOCK(B) & S-LOCK(A) \\
    READ(A) & READ(B) & READ(A) \\
    UPGRADE(A) & X-LOCK(C) & X-LOCK(C) \\
    WRITE(A) & READ(C) & READ(C) \\
    COMMIT & WRITE(C) & WRITE(C) \\
    & COMMIT & COMMIT \\
    \end{tabular}
\end{center}

\noindent Assume that the database executes the transactions in a {\em round-robin} manner --- i.e., each cycle runs one instruction of each transaction --- using the strict 2PL protocol.

(i) If each cycle processes the transactions in the order $T_1, T_2, T_3$, what is the schedule produced?

(ii) If each cycle follows the order of $T_3, T_1, T_2$, what is the schedule produced?

(iii) Give the precedence graphs for the schedules in (i) and (2).

\begin{sol}
    \extraspacing {\bf Solution.} (i)

\begin{center}
    \begin{tabular}{c|c|c}
        no & instruction & remark \\
        \hline
        1 & $T_1:$ U-LOCK(A) & \\
        2 & $T_2:$ S-LOCK(B) & \\
        3 & $T_1:$ READ(A) & $T_3$ on hold at S-LOCK(A)\\
        4 & $T_2:$ READ(B) & \\
        5 & $T_1:$ UPGRADE(A) & \\
        6 & $T_2:$ X-LOCK(C) & \\
        7 & $T_1:$ WRITE(A) & \\
        8 & $T_2:$ READ(C) & \\
        9 & $T_1:$ COMMIT & $T_1$ releases all locks \\
        10 & $T_2:$ WRITE(C) & \\
        11 & $T_3:$ S-LOCK(A) & $T_3$ resumes \\
        12 & $T_2:$ COMMIT & $T_2$ releases all locks \\
        13 & $T_3:$ READ(A) & \\
        14 & $T_3:$ X-LOCK(C) & \\
        15 & $T_3:$ READ(C) & \\
        16 & $T_3:$ WRITE(C) & \\
        17 & $T_3:$ COMMIT&
    \end{tabular}
\end{center}

(ii)

\begin{center}
 \begin{tabular}{c|c|c}
 no & instruction & remark \\
 \hline
 1 & $T_3:$ S-LOCK(A) & \\
 2 & $T_1:$ U-LOCK(A) & granted (existing locks on X are S-locks) \\
 3 & $T_2:$ S-LOCK(B) & \\
 4 & $T_3:$ READ(A) & \\
 5 & $T_1:$ READ(A) & \\
 6 & $T_2:$ READ(B) & \\
 7 & $T_3:$ X-LOCK(C) & \\
8 & $T_3:$ READ(C) & $T_1$ on hold at UPGRADE(A); $T_2$ on hold at X-LOCK(C)\\
9 & $T_3:$ WRITE(C) & \\
10 & $T_3:$ COMMIT & $T_3$ releases all locks \\
11 & $T_1:$ UPGRADE(A) & \\
12 & $T_2:$ X-LOCK(C) & \\
13 & $T_1:$ WRITE(A) & \\
14 & $T_2:$ READ(C) & \\
15 & $T_1:$ COMMIT & \\
16 & $T_2:$ WRITE(C) & \\
17 & $T_2:$ COMMIT &
\end{tabular}
\end{center}

(iii) The precedence graph for (i) is

\begin{center}
    \includegraphics[height=25mm]{./artwork/p2-p-graph1}
\end{center}

The precedence graph for (ii) is

\begin{center}
    \includegraphics[height=25mm]{./artwork/p2-p-graph2}
\end{center}
\end{sol}

\extraspacing {\bf Problem 3.} Prove: Strict 2PL can never produce the following schedule:

\begin{center}
 \begin{tabular}{c|c}
 no & instruction \\
 \hline
 ... & ... \\
 1 & $T_1:$ READ(A) \\
 ... & ... \\
 2 & $T_2:$ WRITE(A) \\
 ... & ...  \\
 3 & any instruction of $T_1$ \\
 ... & ...
 \end{tabular}
\end{center}

\begin{sol}
    \extraspacing {\bf Solution.} $T_1$ must be holding a lock on A at instruction 1. As $T_1$ is still running at Instruction 3, it must be holding {\em some} lock on $A$ at Instruction 2 (recall that $T_1$ releases locks only after it commits). However, when $T_2$ writes to A at Instruction 2, no other transactions can be holding any lock on $A$. This creates a contradiction.
\end{sol}

\extraspacing {\bf Problem 4.} Prove: Strict 2PL can never produce the following schedule:

\begin{center}
 \begin{tabular}{c|c}
 no & instruction \\
 \hline
 ... & ... \\
 1 & $T_1:$ WRITE(A) \\
 ... & ... \\
 2 & $T_2:$ READ(A) \\
 ... & ...  \\
 3 & $T_2:$ COMMIT \\
 ... & ... \\
 4 & $T_1:$ COMMIT \\
 ... & ...
 \end{tabular}
\end{center}

\begin{sol}
    \extraspacing {\bf Solution.} When $T_1$ writes to A at Instruction 1, it holds an X-lock on $A$, and no other transactions can be holding any lock on $A$. Hence, $T_2$ cannot be holding any lock on $A$ at Instruction 1. However, at Instruction 2, $T_2$ is holding {\em some} lock on $A$; thus, it must have acquired the lock sometime between Instructions 1 and 2. However, as $T_1$ commits at Instruction 4, it must be holding an X-clock on $A$ throughout the period from Instruction 1 to Instruction 4. This prevents $T_2$ from acquiring any lock in that period, giving a contradiction.
\end{sol}

\extraspacing

\begin{center}
    \uline{Critical Thinking}
\end{center}

\extraspacing {\bf Problem 5.} We have a relation \ttt{ACC}(\ttt{id}, \ttt{balance}). Consider the following order of instructions.

\begin{center}
    \begin{tabular}{c|c|c}
        & $T_1$ & $T_2$ \\
        \hline
        1 & \ttt{select sum}(\ttt{balance}) \ttt{from ACC} & \\
        2 && \ttt{update ACC set balance} = \ttt{balance} + 100 \\
        3 & \ttt{update ACC set balance} = \ttt{balance} + 100 & \\
        4 & & \ttt{select sum}(\ttt{balance}) \ttt{from ACC}
    \end{tabular}
\end{center}

Suppose that $T_1$ and $T_2$ both run at the ``serializable'' isolation level. Explain how strict 2PL ensures serializability if the instructions are executed in the order shown.


\extraspacing {\bf Problem 6.} Prove: Strict 2PL can never produce the following schedule:

\begin{center}
 \begin{tabular}{c|c}
 no & instruction \\
 \hline
 ... & ... \\
 1 & $T_1:$ READ(A) \\
 ... & ... \\
 2 & $T_2:$ READ(B) \\
 ... & ...  \\
 3 & $T_3:$ WRITE(C) \\
 ... & ... \\
 4 & $T_2:$ WRITE(A) \\
 ... & ... \\
 5 & $T_3:$ WRITE(B) \\
 ... & ... \\
 6 & $T_1:$ READ(C) \\
 ... & ...
 \end{tabular}
\end{center}

\extraspacing {\bf Problem 7.} The strict 2PL protocol we have learned has a ``non-strict'' variant. Specifically, the non-strict 2PL protocol enforces all of Rules 1-4 in the ``two phase locking'' lecture, plus a {\bf modified} Rule 5: once a transaction starts releasing a lock, it can no longer acquire any new lock. Note that the modified rule does not require the transaction to hold all locks till commit.

\vgap

Show that the non-strict 2PL can produce non-recoverable schedules. (Hint: Problem 4.)

\end{document}
