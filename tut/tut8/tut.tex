%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\extraspacing{\vspace{5mm} \noindent}

\def\best{\mathit{best}}
\def\size{\mathit{size}}

\newboolean{solver}\setboolean{solver}{true}
%\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Tutorial 8}
Prepared by Yufei Tao \\

\begin{center}
    \uline{Classroom Discussion}
\end{center}

Consider three relations: $R_1(A, B)$ --- that is, a relation with attributes $A$ and $B$ --- $R_2(A, C)$, and $R_3(A, D)$, where $A$, $B$, and $C$ are all integer  attributes. We know the following facts:

\myitems{
    \item Fact 0.1: Each disk block can store 20 integer values.
    \item Fact 0.2: $|R_1| = |R_2| = |R_3| = 10^7$ (i.e., each relation has $10^7$ tuples). Each of $R_1$, $R_2$, and $R_3$ occupies $10^6$ disk blocks.
    \item Fact 0.3: The attribute $A$ is the primary key of $R_1$ and $R_3$, but not of $R_2$.
    \item Fact 0.4: There is a B-tree on $R_1$ indexing the attribute $A$. The B-tree has 3 levels.
    \item Fact 0.5: The memory has $M = 2500$ blocks.
}

\extraspacing {\bf Problem 1.} Suppose we also know:
\myitems{
    \item Fact 1.1:
    50\% of the tuples in $R_2$ satisfy $C \ge 100$.
}
Given the query

%Describe how to process the following query with no more than $13 \times 10^6$ I/Os (the query result is displayed on screen).

\mytab{
    \> \ttt{select} * {from} $R_1, R_2, R_3$ \\
    \> \ttt{where} $R_1.A = R_2.A$ \ttt{and} $R_2.A = R_3.A$ \ttt{and} $R_2.C \ge 100$;
}
we process it using the plan below:
\myenums{
    \item Scan $R_2$ to materialize
    \myeqn{
        %R_1' = \{\text{tuple } t \in R_1 \mid t.B \ge 100\} \nn \\
        R_4 = \{\text{tuple } t \in R_2 \mid t.C \ge 100\}. \nn
    }

    \item  Compute
    \myeqn{
        R_5 = R_1 \bowtie R_4 \nn
    }
    using hash-join (HJ) and materialize it.

    \item Compute $R_5 \bowtie R_3$ using HJ.
}
\noindent Provide an argument to show that the above plan performs no more than $13 \times 10^6$ I/Os, assuming that the query result is displayed on screen. Whenever needed, you can make the good hashing assumption for HJ.

\begin{sol}
\extraspacing {\bf Solution.} By Facts 0.2 and 1.1, the I/O cost of Step 1 is $10^6 + 5 \times 10^5 = 1.5 \times 10^6$ I/Os. The relation $R_4$ occupies $5 \times 10^5$ blocks. As $|R_4| = 5 \times 10^6$, Fact 0.3 tells us that $R_5$ has at most $5 \times 10^6$ tuples. A block can store $\lf 20/3 \rf = 6$ tuples of $R_5$ (each tuple has 3 integers). Hence, $R_5$ fits in $\lc 5 \times 10^6 / 6 \rc = 833,334$ blocks. The I/O cost of Step 2 is thus at most $3 (10^6 + 5 \times 10^5) + 833,334 = 5,333,334$. Finally, Step 3 takes $3 (833,334 + 10^6) = 5,500,002$ I/Os.

\vgap

The total cost is no more than $1.5 \times 10^6 + 5,333,334 + 5,500,002 = 12,333,336$ I/Os.

\end{sol}

\extraspacing {\bf Problem 2.} Suppose we also know:
\myitems{
    \item Fact 2.1: 1\% of the tuples in $R_2$ satisfy $C \ge 1000$.
}
Given the query

%Describe how to process the following query with no more than $13 \times 10^6$ I/Os (the query result is displayed on screen).

\mytab{
    \> \ttt{select} * {from} $R_1, R_2, R_3$ \\
    \> \ttt{where} $R_1.A = R_2.A$ \ttt{and} $R_2.A = R_3.A$ \ttt{and} $R_2.C \ge 1000$ \\
    \> \ttt{order by} $R_1.A$;
}
We process it using the plan below:
\myenums{
    \item Scan $R_2$ to obtain
    \myeqn{
        %R_1' = \{\text{tuple } t \in R_1 \mid t.B \ge 100\} \nn \\
        R_4 = \{\text{tuple } t_2 \in R_2 \mid t_2.C \ge 1000\}. \nn
    }
    {\bf without} materializing it.

    \item  Compute
    \myeqn{
        R_5 = R_1 \bowtie R_4 \nn
    }
    and materialize it.

    \item Compute
    \myeqn{
        R_6 = R_5 \bowtie R_3 \nn
    }
    and materialize it.

    \item Output $R_6$ in ascending order of attribute $A$.
}
\noindent Provide an argument to show that the above plan performs no more than $5 \times 10^6$ I/Os, assuming that the query result is displayed on screen. Whenever needed, you can make (i) the no-skew assumption for sort-join (SJ) and (ii) the good hashing assumption for HJ.

\begin{sol}
    \extraspacing {\bf Solution.} By Fact 2.1, relation $R_4$ has $10^5$ tuples and fits in $10^4$ blocks. Every time we find a tuple $t_2 \in R_2$ with $t_2.C \ge 1000$, we search the B-tree of $R_1$ to see if there is a tuple $t_1 \in R_1$ satisfying $t_1.A = t_2.A$ (note: there can be at most one such tuple because $A$ is the primary key of $R_1$). Since each search cost takes 4 I/Os (the B-tree has 3 levels; see Fact 0.4), doing the search for all the tuples in $R_4$ requires $4 \times 10^5$ I/Os. Relation $R_5$ has at most $10^5$ tuples and fits in $\lc 10^5 / 6 \rc = 16667$ blocks (each tuple has 3 integers). Hence, Steps 1 and 2 can be performed in $
        10^6 \text{ (for reading $R_2$)} + 4 \times 10^5 + 16667 = 1,416,667
    $ I/Os.

    \vgap

    $R_6$ has at most $10^5$ tuples. As each tuple of $R_6$ has 4 integers, a block can contain 5 tuples of $R_6$, which thus fits in $10^5 / 5 = 20000$ blocks. We can compute  and materialize $R_6$ using HJ in $3 \times (16667 + 10^6) + 20000 = 3,070,001$ I/Os.
    Finally, we carry out Step 4 using external sort, which requires at most $4 \times 20000 = 80000$ I/Os.

    \vgap

    The total I/O cost is therefore $1,416,667 + 3,070,001 + 80,000 =4,566,668$ I/Os.
\end{sol}



\extraspacing {\bf Problem 3.} Suppose we also know:
\myitems{
    \item Fact 3.1: 0.1\% of the tuples in $R_2$ satisfy $C \ge 10000$.
}
Consider the query

%Describe how to process the following query with no more than $13 \times 10^6$ I/Os (the query result is displayed on screen).

\mytab{
    \> \ttt{select} * {from} $R_1, R_2, R_3$ \\
    \> \ttt{where} $R_1.A = R_2.A$ \ttt{and} $R_2.A = R_3.A$ \ttt{and} $R_2.C \ge 10000$ \\
    \> \ttt{order by} $R_1.A$;
}

\noindent Describe a plan to process the query in no more than $2.5 \times 10^6$ I/Os, assuming that the query result is displayed on screen.


\begin{sol}
    \extraspacing {\bf Solution.}
    Scan $R_2$ to obtain
    \myeqn{
        %R_1' = \{\text{tuple } t \in R_1 \mid t.B \ge 100\} \nn \\
        R_4 = \{\text{tuple } t_2 \in R_2 \mid t_2.C \ge 10000\}. \nn
    }
    By Fact 3.1, $R_4$ has $10^4$ tuples and fits in 1000 blocks. As the memory has $M = 2500$ blocks, we can keep the entire $R_4$ in memory.

    \vgap

    Next, we compute
    \myeqn{
        R_5 = R_1 \bowtie R_4. \nn
    }
    Towards the purpose, for each tuple $t_4 \in R_4$, we search on the B-tree of $R_1$ to see if there is a tuple $t_1 \in R_1$ satisfying $t_1.A = t_4.A$. Since each search cost takes 4 I/Os (the B-tree has 3 levels), doing the search for all the tuples in $R_4$ requires $4 \times 10^4$ I/Os. Relation $R_5$ has at most $10^4$ tuples, fits in $\lc 10^4 / 6 \rc = 1667$ blocks, and can be stored in memory.

    \vgap

    Next, we compute
    \myeqn{
        R_6 = R_5 \bowtie R_3. \nn
    }
    with one scan over $R_3$ while keeping $R_5$ in memory. The tuples of $R_6$ are written to the disk.
    Relation $R_6$ has at most $10^4$ tuples. As each tuple of $R_6$ has 4 integers, a block can contain 5 tuples of $R_6$, which thus fits in $10^4 / 5 = 2000$ blocks.  Finally, load $R_6$ into memory, sort it, and output its tuples in ascending order of attribute $A$.

    \vgap

    The total I/O cost is $10^6 \text{ (for reading $R_2$)} + 4 \times 10^4 + 10^6 \text{ (for reading $R_3$)} + 10^4 \text{ (for writing $R_6$)} + 10^4 \text{ (for reading $R_6$)} = 2,060,000$.
\end{sol}

\extraspacing {\bf Problem 4.} Let $R_1, R_2, ..., R_4$ be four relations. The table below shows the result sizes of all possible natural joins involving at least two relations.

\begin{center}
    \begin{tabular}{c|c}
        $S$ & join size \\
        \hline
        $R_1,R_2$ & 1000 \\
        $R_1,R_3$ & 100 \\
        $R_1,R_4$ & 5000 \\
        $R_2,R_3$ & 2000 \\
        $R_2,R_4$ & 700 \\
        $R_3,R_4$ & 300 \\
        $R_1, R_2, R_3$ & 10000 \\
        $R_1, R_2, R_4$ & 15000 \\
        $R_1, R_3, R_4$ & 8000 \\
        $R_2, R_3, R_4$ & 60000 \\
        $R_1, R_2, R_3, R_4$ & 200000
    \end{tabular}
\end{center}

\noindent For each of these natural joins, find the optimal join order.

\begin{sol}
    \extraspacing {\bf Solution.} We demonstrate the execution of the dynamic programming algorithm on the provided input. First, the algorithm looks at all possible size-2 subsets of $\set{R_1, R_2, R_3, R_4}$. For each such subset $S$, the algorithm queries the size oracle to obtain $\size(S)$ and then sets $\best(S) = \size(S)$. By doing so, it generates the following table:

    \begin{center}
    \begin{tabular}{c|c|c}
        $S$ & best (smallest) penalty & best order\\
        \hline
        $R_1,R_2$ & 1000 & $R_1 \bowtie R_2$ \\
        $R_1,R_3$ & 100 & $R_1 \bowtie R_3$\\
        $R_1,R_4$ & 5000 & $R_1 \bowtie R_4$\\
        $R_2,R_3$ & 2000 & $R_2 \bowtie R_3$\\
        $R_2,R_4$ & 700 & $R_2 \bowtie R_4$\\
        $R_3,R_4$ & 300 & $R_3 \bowtie R_4$
    \end{tabular}
    \end{center}

    \noindent Note that the order in the last column of the above table does not matter (e.g., $R_2 \bowtie R_1$ is also an optimal order for $S = \set{R_1, R_2}$).

    \vgap

    Next, the algorithm looks at all possible size-3 subsets of $\set{R_1, R_2, R_3, R_4}$. To illustrate consider $S = \set{R_1, R_2, R_3}$. If $R_1$ is the last relation in the join order, the  penalty is $\best(\set{R_2, R_3}) + \size(S) = 2000 + 10000 = 12000$. If $R_2$ is the last relation in the join order, the penalty is $\best(\set{R_1, R_3}) + \size(S) = 100 + 10000 = 10100$. If $R_3$ is the last relation in the join order, the penalty is $\best(\set{R_1, R_2}) + \size(S) = 1000 + 10000 = 11000$. Therefore, the lowest possible penalty is 10100 and the optimal join order for $\set{R_1, R_2, R_3}$ is $R_1 \bowtie R_3 \bowtie R_2$. After processing every size-3 subset in the same manner, the algorithm creates the following table:

        \begin{center}
    \begin{tabular}{c|c|c}
        $S$ & best (smallest) penalty & best order\\
        \hline
        $R_1,R_2,R_3$ & 10100 & $R_1 \bowtie R_3 \bowtie R_2$ \\
        $R_1,R_2,R_4$ & 15700 & $R_2 \bowtie R_4 \bowtie R_1$\\
        $R_1,R_3,R_4$ & 8100 & $R_1 \bowtie R_3 \bowtie R_4$\\
        $R_2,R_3,R_4$ & 60300 & $R_3 \bowtie R_4 \bowtie R_2$
    \end{tabular}
    \end{center}

    Finally, the algorithm looks at $S = \set{R_1, R_2, R_3, R_4}$. If $R_1$ is the last relation in the join order, the penalty is $\best(\set{R_2, R_3, R_4}) + \size(S) = 60300 + 200000 = 260300$. If $R_2$ is the last relation in the join order, the penalty is $\best(\set{R_1, R_3, R_4}) + \size(S) = 8100 + 200000 = 208100$.
    If $R_3$ is the last relation in the join order, the penalty is $\best(\set{R_1, R_2, R_4}) + \size(S) = 15700 + 200000 = 215700$.
    If $R_4$ is the last relation in the join order, the penalty is $\best(\set{R_1, R_2, R_3}) + \size(S) = 10100 + 200000 = 210100$. Therefore, the lowest possible penalty is 208100 and the optimal join order for $S$ is $R_1 \bowtie R_3 \bowtie R_4 \bowtie R_2$.
\end{sol}


\vgap

\begin{center}
    \uline{Critical Thinking}
\end{center}



\extraspacing {\bf Problem 5.} Describe an alternative plan to process the query in Problem 1 using at most $11.5 \times 10^6$ I/Os assuming one more condition:
\myitems{
    \item $R_1$ is sorted on $A$.
}

% \begin{sol}
% \extraspacing {\bf Solution.} First, compute and materialize $R_4$ in $1.5 \times 10^6$ I/Os as before. As $R_4$ occupies $5 \times 10^5$ blocks, sorting $R_4$ on $A$ requires $4 \times (5 \times 10^5) = 2 \times 10^6$ I/Os. We can then compute and materialize $R_5$ using sort-join (SJ) in $10^6 + 5 \times 10^5 + 833,334 = 2,333,334$ I/Os. Finally, computing $R_5 \bowtie R_3$ in $5,500,002$ I/Os as before.
%
% \vgap
%
% The total cost is no more than $1.5 \times 10^6 + 2 \times 10^6 + 2,333,334 + 5,500,002 = 11,333,336$ I/Os.
%
% \end{sol}


\extraspacing {\bf Problem 6*.} Suppose we also know:
\myitems{
    \item 1\% of the tuples in $R_2$ satisfy $C \ge 1000$.
}
Given the query

%Describe how to process the following query with no more than $13 \times 10^6$ I/Os (the query result is displayed on screen).

\mytab{
    \> \ttt{select} $R_1.A$, \ttt{sum}($R_2.B$) {from} $R_1, R_2, R_3$ \\
    \> \ttt{where} $R_1.A = R_2.A$ \ttt{and} $R_2.A = R_3.A$ \ttt{and} $R_2.C \ge 1000$ \\
    \> \ttt{group by} $R_1.A$;
}

\noindent describe a plan to process the query in at most $3.5 \times 10^6$ I/Os, assuming that the query result is displayed on screen.
(Hint: Run the strategy in the solution to Problem 2 but discard attributes $C$ and $D$ as early as you can.)

\end{document}
