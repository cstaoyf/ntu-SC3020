%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\dom{\prec}
\def\T{\mathcal{T}}

\def\vgap{\vspace{3mm}}

%\newboolean{solver}\setboolean{solver}{true}
\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Project 2}

Prepared by Yufei Tao \\
Oct 2025 \\


\section{Main Objective}

This project is designed to deepen your understanding of query optimization and concurrency control through hands-on experience on a real database system.

\section{Setup}

This guide assumes that you are using Windows, which is the operating system installed on all the machines in the CCDS labs.

\vgap

First, download PostgreSQL at \url{https://www.postgresql.org/download} and install it. Make sure \ttt{pgAdmin4} is working --- this is a utility program that allows you to access and manage the database with a friendly GUI.

\vgap

Second, download the file \ttt{proj2-data.zip} from NTULearn (look for \ttt{Project 2} and then \ttt{Data for Project 2}). Unzip the file and you should see 8 \ttt{csv} files. These files were generated according to the TPC-H benchmark (see \url{https://www.tpc.org/tpch} for the details of TPC-H).

\vgap

Third, download the file \ttt{table-creation.txt} from NTULearn (look for \ttt{Project 2} and then \ttt{Table Creation Statements}). Use \ttt{pgAdmin4} to create a new database in PostgreSQL, and then use the statements in \ttt{table-creation.txt} to create 9 tables inside that database. Make sure that you see the following tables in \ttt{pgAdmin4}:
\myitems{
    \item \ttt{customer} \vspace{-2mm}
    \item \ttt{lineitem} \vspace{-2mm}
    \item \ttt{nation} \vspace{-2mm}
    \item \ttt{orders} \vspace{-2mm}
    \item \ttt{part} \vspace{-2mm}
    \item \ttt{partsupp} \vspace{-2mm}
    \item \ttt{region} \vspace{-2mm}
    \item \ttt{supplier} \vspace{-2mm}
    \item \ttt{t}.
}

Fourth, use \ttt{pgAdmin4} to import data into the first 8 tables from the \ttt{csv} files you obtained earlier. The file names match the table names in a straightforward manner (e.g., file \ttt{customer.csv} is for table \ttt{customer}). Note the foreign key constraints on the tables; choose a table ordering to do the importing by respecting those constraints.

\section{Tasks}

\subsection{Query Optimization}

Familiarize yourself with the use of \ttt{explain} and \ttt{analyze} in PostgreSQL:
\myitems{
    \item By putting \ttt{explain} before an SQL query prompts the system to explain the execution plan selected for the query. For example, try: \\
    \ttt{explain select * from lineitem;} \\
    to see what happens.

    \item By putting \ttt{explain analyze} before an SQL query prompts the system to (i) explain the execution plan selected for the query and (ii) physically execute the plan to obtain the actual performance statistics. For example, try: \\
    \ttt{explain analyze select * from lineitem;} \\
    to see what happens.
}

\subsubsection{Task 1}

The \ttt{d+} command allows you to find the basic information of each table. Figure out the syntax of \ttt{d+} from online sources. Identify the index that PostgreSQL creates on each table automatically.

\subsubsection{Task 2}

Boot up your system and run the following as your first query.

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Run the query for a second time. Does it ``feel'' faster? How much faster? Why did it happen?

\subsubsection{Task 3}

Create an index with the following statement:

\vgap

\noindent \ttt{create index idx\_lineitem\_quantity on lineitem (l\_quantity);}

\vgap

\noindent Use \ttt{d+} to find out what index it is. Now run again

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen in Task 2? Why?

\vgap

\noindent Before proceeding to the next task, use the following statement to remove the index.

\vgap

\noindent \ttt{drop index idx\_lineitem\_quantity;}

\subsubsection{Task 4}

Create an index with the following statement:

\vgap

\noindent \ttt{create index  idx\_lineitem\_quantity\_hash on lineitem using hash (l\_quantity);}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen in Task 3? Why?

\noindent Now run instead

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen for the previous query? Why?


\vgap

\noindent Before proceeding to the next task, use the following statement to remove the index.

\vgap

\noindent \ttt{drop index idx\_lineitem\_quantity\_hash;}

\subsubsection{Task 5}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select l\_orderkey, l\_suppkey, sum(l\_quantity) as sum\_qty} \\
\ttt{from lineitem} \\
\ttt{group by l\_suppkey, l\_orderkey} \\
\ttt{order by l\_suppkey, l\_orderkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query.

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1000MB';}

\vgap

\noindent Run the same query again and explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan used for 1MB of working memory? Why?

\subsubsection{Task 6}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\noindent \ttt{where l1.l\_orderkey = l2.l\_suppkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. To do so, you need to learn from online sources the meaning of a {\em batch} (this is a concept specific to the hash join implementation of PostgreSQL).

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Run the same query again and explain how the query plan has changed? Why did this happen?

\subsubsection{Task 7}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\noindent \ttt{where l1.l\_orderkey = l2.l\_suppkey} \\
\noindent \ttt{order by l2.l\_suppkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from what you saw in Task 6? Why?

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1000MB';}

\vgap

\noindent Run the same query again and explain how the query plan has changed. Why did this happen?

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '2000MB';}

\vgap

\noindent Run the same query for a third time and explain how the query plan has changed. Why did this happen?

\subsubsection{Task 8}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_orderkey = o.o\_orderkey order by o.o\_orderkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Was any sorting performed? Why did this happen?

\vgap

\noindent If it helps, you can use the following command to see how the tuples of a relation (here we use \ttt{orders} as an example) are physically ordered on disk:

\vgap

\noindent \ttt{select ctid, * from orders LIMIT 100;}

\subsubsection{Task 9}

Execute the following commands:

\vgap

\noindent \ttt{set work\_mem = '1MB';} \\
\noindent \ttt{create index idx\_lineitem\_quantity on lineitem (l\_quantity);}

\vgap

\noindent Now run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_partkey = o.o\_custkey and l.l\_quantity = 20} \\
\ttt{order by o.o\_custkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Did the plan use the index \ttt{idx\_lineitem\_quantity} we built? How do you explain this?

\vgap

\noindent Now run instead:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_partkey = o.o\_custkey and l.l\_orderkey <= 10000 } \\
\ttt{order by o.o\_custkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Did the plan use any indexes? How do you explain this?

\subsubsection{Task 10}

\noindent Run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\ttt{where l1.l\_orderkey = l2.l\_orderkey;}

\vgap

\noindent What was the result size predicted by the query planner? What is the actual result size?

\vgap

\noindent Run the following three queries:

\myitems{
    \item \noindent \ttt{select count(*) from lineitem;}

    \item \noindent \ttt{select count(*) from lineitem l1, lineitem l2} \\
    \ttt{where l1.l\_orderkey = l2.l\_orderkey;}

    \item \noindent \ttt{select count(*) from lineitem l1, lineitem l2, lineitem l3} \\
    \ttt{where l1.l\_orderkey = l2.l\_orderkey and l2.l\_orderkey = l3.l\_orderkey;}
}

\noindent How do you explain the running time differences of the above queries? By the way, you can terminate the 3rd query if it fails to terminate within 5 minutes.

\vgap

\noindent Can you describe an algorithm that can process all three queries with negligible cost differences?


\subsection{Transactions}

\subsubsection{Task 11}

First, execute the command:

\vgap

\noindent
\ttt{insert into public.t values(1, 10);}

\vgap

\noindent Now, start a transaction: \\

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL READ COMMITTED;}

\vgap

\noindent \ttt{Run the following query}, which we will refer to as $Q1$:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent Open {\em another} command-line session (in pgAdmin4, go to menu \ttt{Tools} and then click on \ttt{PSQL Tool}). In this session, execute the following commands:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL SERIALIZABLE;}  \\
\noindent \ttt{insert into public.t values(2, 20);}  \\
\noindent \ttt{COMMIT;}

\vgap

\noindent Now, go back to the first command-line session, and execute the following query, which we will refer to as $Q2$:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent Are the results of $Q1$ and $Q2$ identical? What anomalies --- according to the lecture slides ``Transactions 2:
Isolation Levels'' --- have you witnessed? Why is this allowed?

\vgap

\noindent Before proceeding, close both command-line sessions.






\end{document}
