%\documentclass{...}

\input{./def/yf-formatting}

\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{latexsym}
%\usepackage{times}
\usepackage[normalem]{ulem}

\input{./def/yf-def}

\def\dom{\prec}
\def\T{\mathcal{T}}

\def\vgap{\vspace{3mm}}

%\newboolean{solver}\setboolean{solver}{true}
\newboolean{solver}\setboolean{solver}{false}
\ifthenelse{\boolean{solver}}{\includecomment{sol}}{\excludecomment{sol}}

\begin{document}

\section*{SC3020-CE4301-CZ4031: Project 2}

Prepared by Yufei Tao \\
15 Oct, 2025 \\

\vgap

\noindent \red{\bf DEADLINE: 11:59pm, 20 Nov, 2025}.


\section{Main Objective}

This project is designed to deepen your understanding of query optimization and concurrency control through authentic experience on a real database system.

\section{Setup}

This guide assumes that you are using Windows, which is the operating system installed on all the machines in the CCDS labs.

\vgap

First, download PostgreSQL at \url{https://www.postgresql.org/download} and install it. Make sure \ttt{pgAdmin4} is working --- this is a utility program that allows you to access and manage the database with a friendly GUI.

\vgap

Second, download the file \ttt{proj2-data.zip} from NTULearn (look for \ttt{Project 2} and then \ttt{Data for Project 2}). Unzip the file and you should see 8 \ttt{csv} files. These files were generated according to the TPC-H benchmark (see \url{https://www.tpc.org/tpch} for the details of TPC-H).

\vgap

Third, download the file \ttt{table-creation.txt} from NTULearn (look for \ttt{Project 2} and then \ttt{Table Creation Statements}). Use \ttt{pgAdmin4} to create a new database in PostgreSQL, and then use the statements in \ttt{table-creation.txt} to create 9 tables inside that database. Make sure that you see the following tables in \ttt{pgAdmin4}:
\myitems{
    \item \ttt{customer} \vspace{-2mm}
    \item \ttt{lineitem} \vspace{-2mm}
    \item \ttt{nation} \vspace{-2mm}
    \item \ttt{orders} \vspace{-2mm}
    \item \ttt{part} \vspace{-2mm}
    \item \ttt{partsupp} \vspace{-2mm}
    \item \ttt{region} \vspace{-2mm}
    \item \ttt{supplier} \vspace{-2mm}
    \item \ttt{t}
}

Fourth, use \ttt{pgAdmin4} to import data into the first 8 tables from the \ttt{csv} files you obtained earlier. The file names match the table names in a straightforward manner (e.g., file \ttt{customer.csv} is for table \ttt{customer}). Note the foreign key constraints on the tables; choose a table ordering to do the importing by respecting those constraints.

\section{Tasks}

\subsection{Query Optimization}

Familiarize yourself with the use of \ttt{explain} and \ttt{analyze} in PostgreSQL:
\myitems{
    \item Putting \ttt{explain} before an SQL query prompts the system to explain the execution plan selected for the query. For example, try: \\
    \ttt{explain select * from lineitem;} \\
    to see what happens.

    \item Putting \ttt{explain analyze} before an SQL query prompts the system to (i) explain the execution plan selected for the query and (ii) physically execute the plan to obtain the actual performance statistics. For example, try: \\
    \ttt{explain analyze select * from lineitem;} \\
    to see what happens.
}

\subsubsection{Task 1}

The \ttt{d+} command allows you to find the basic information of each table. Figure out the syntax of \ttt{d+} from online sources. Identify the index that PostgreSQL creates on each table automatically.

\subsubsection{Task 2}

Boot up your system and run the following as your first query.

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Run the query for a second time. Does it ``feel'' faster? How much faster? Why did it happen?

\subsubsection{Task 3}

Create an index with the following statement:

\vgap

\noindent \ttt{create index idx\_lineitem\_quantity on lineitem (l\_quantity);}

\vgap

\noindent Use \ttt{d+} to find out what index it is. Now run again

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen in Task 2? Why?

\vgap

\noindent Before proceeding to the next task, use the following statement to remove the index.

\vgap

\noindent \ttt{drop index idx\_lineitem\_quantity;}

\subsubsection{Task 4}

Create an index with the following statement:

\vgap

\noindent \ttt{create index  idx\_lineitem\_quantity\_hash on lineitem using hash (l\_quantity);}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $>=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen in Task 3? Why?

\vgap

\noindent Now run instead

\vgap

\noindent \ttt{explain analyze select * from lineitem where l\_quantity $=$ 50;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan chosen for the previous query? Why?


\vgap

\noindent Before proceeding to the next task, use the following statement to remove the index.

\vgap

\noindent \ttt{drop index idx\_lineitem\_quantity\_hash;}

\subsubsection{Task 5}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select l\_orderkey, l\_suppkey, sum(l\_quantity) as sum\_qty} \\
\ttt{from lineitem} \\
\ttt{group by l\_suppkey, l\_orderkey} \\
\ttt{order by l\_suppkey, l\_orderkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query.

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1000MB';}

\vgap

\noindent Run the same query again and explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from the plan used for 1MB of working memory? Why?

\subsubsection{Task 6}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\noindent \ttt{where l1.l\_orderkey = l2.l\_suppkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. To do so, you need to learn from online sources the meaning of a {\em batch} (this is a concept specific to the hash join implementation of PostgreSQL).

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '64MB';}

\vgap

\noindent Run the same query again and explain how the query plan has changed? Why did this happen?

\subsubsection{Task 7}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\noindent \ttt{where l1.l\_orderkey = l2.l\_suppkey} \\
\noindent \ttt{order by l2.l\_suppkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Is it different from what you saw in Task 6? Why?

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1000MB';}

\vgap

\noindent Run the same query again and explain how the query plan has changed. Why did this happen?

\vgap

\noindent Now, execute the following command:

\vgap

\noindent \ttt{set work\_mem = '2000MB';}

\vgap

\noindent Run the same query for a third time and explain how the query plan has changed. Why did this happen?

\subsubsection{Task 8}

Execute the following command:

\vgap

\noindent \ttt{set work\_mem = '1MB';}

\vgap

\noindent Now run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_orderkey = o.o\_orderkey order by o.o\_orderkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Was any sorting performed? Why did this happen?

\vgap

\noindent If it helps, you can use the following command to see how the tuples of a relation (here we use \ttt{orders} as an example) are physically ordered on disk:

\vgap

\noindent \ttt{select ctid, * from orders LIMIT 100;}

\subsubsection{Task 9}

Execute the following commands:

\vgap

\noindent \ttt{set work\_mem = '1MB';} \\
\noindent \ttt{create index idx\_lineitem\_quantity on lineitem (l\_quantity);}

\vgap

\noindent Now run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_partkey = o.o\_custkey and l.l\_quantity = 20} \\
\ttt{order by o.o\_custkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Did the plan use the index \ttt{idx\_lineitem\_quantity} we built? How do you explain this?

\vgap

\noindent Now run instead:

\vgap

\noindent \ttt{explain analyze select * from lineitem l, orders o} \\
\ttt{where l.l\_partkey = o.o\_custkey and l.l\_orderkey <= 10000 } \\
\ttt{order by o.o\_custkey;}

\vgap

\noindent Explain in plain words the query plan that PostgreSQL selects to answer the query. Did the plan use any indexes? How do you explain this?

\vgap

\noindent{Before finishing this task, execute the command below:}

\vgap

\noindent \ttt{drop index idx\_lineitem\_quantity;}

\subsubsection{Task 10}

\noindent Run:

\vgap

\noindent \ttt{explain analyze select * from lineitem l1, lineitem l2} \\
\ttt{where l1.l\_orderkey = l2.l\_orderkey;}

\vgap

\noindent What was the result size predicted by the query planner? What is the actual result size?

\vgap

\noindent Run the following three queries:

\myitems{
    \item \noindent \ttt{select count(*) from lineitem;}

    \item \noindent \ttt{select count(*) from lineitem l1, lineitem l2} \\
    \ttt{where l1.l\_orderkey = l2.l\_orderkey;}

    \item \noindent \ttt{select count(*) from lineitem l1, lineitem l2, lineitem l3} \\
    \ttt{where l1.l\_orderkey = l2.l\_orderkey and l2.l\_orderkey = l3.l\_orderkey;}
}

\noindent How do you explain the running time differences of the above queries? By the way, you can terminate the 3rd query if it fails to terminate within 5 minutes.

\vgap

\noindent If you can change the implementation of PostgreSQL, do you see an algorithm that can process all three queries with negligible cost differences?

\vgap

Rewrite the 3rd query into another SQL query that returns the same result in less than 30 seconds (hint: \ttt{group by} and nested SQL).


\subsection{Transactions}

\subsubsection{Task 11}

First, execute the command:

\vgap

\noindent
\ttt{insert into public.t values(1, 10);}

\vgap

\noindent Now, start a transaction:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL READ COMMITTED;}

\vgap

\noindent Run the following query, which we will refer to as $Q1$:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent Open {\em another} command-line session (in pgAdmin4, go to menu \ttt{Tools} and then click on \ttt{PSQL Tool}). In this session, execute the following commands:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL SERIALIZABLE;}  \\
\noindent \ttt{insert into public.t values(2, 20);}  \\
\noindent \ttt{COMMIT;}

\vgap

\noindent Now, go back to the first command-line session, and execute the following query, which we will refer to as $Q2$:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent Are the results of $Q1$ and $Q2$ identical? What anomalies --- according to the lecture slides ``Transactions 2:
Isolation Levels'' --- have you witnessed? Why is this allowed?

\vgap

\noindent Before proceeding, close both command-line sessions.

\subsubsection{Task 12}

Open a new command-line session and execute the command:

\vgap

\noindent \ttt{delete from public.T where id >= 2;}

\vgap

\noindent Start a transaction --- which we denote as $T_1$ --- with:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL SERIALIZABLE;}

\vgap

\noindent \ttt{Run the following query}:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent Open {\em another} command-line session of $T_1$ execute the following commands:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL SERIALIZABLE;}  \\
\noindent \ttt{insert into public.t values(2, 20);}  \\
\noindent \ttt{COMMIT;}

\vgap

\noindent Now, go back to the command-line session of $T_1$ and execute:

\vgap

\noindent \ttt{insert into public.t values(3, 30);}

\vgap

\noindent What do you observe? Why does this happen?

\vgap

\noindent Before proceeding, close both command-line sessions.


\subsubsection{Task 13}

Open a new command-line session and execute the commands:

\vgap

\noindent \ttt{delete from public.T where id >= 2;} \\
\noindent \ttt{insert into public.t values(1, 10);}

\vgap

\noindent If the second command reports a primary key constraint error, it means that the tuple (1, 10) already exists, in which case all is good and you may proceed. Start a transaction --- which we denote as $T_1$ --- with:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL READ COMMITTED;}

\vgap

\noindent Open {\em another} command-line session and start a transaction --- which we denote as $T_2$ --- with:

\vgap

\noindent \ttt{START TRANSACTION ISOLATION LEVEL READ COMMITTED;}

\vgap

\noindent Go to the session of $T_1$ and execute:

\vgap

\noindent \ttt{update public.T set v = 20 where id = 1;}

\vgap

\noindent Now, go to the session of $T_2$ and execute:

\vgap

\noindent \ttt{update public.T set v = 30 where id = 1;}

\vgap

\noindent What do you observe? Why does this happen?

\vgap

\noindent Return to the session of $T_1$ and execute:

\vgap

\noindent \ttt{COMMIT;}

\vgap

\noindent Switch back to the session of $T_2$. What do you observe? Why does it happen?

\vgap

\noindent In the session of $T_2$, execute:

\vgap

\noindent \ttt{select * from public.t;}

\vgap

\noindent What do you see? Now execute the following commands:

\vgap

\noindent \ttt{ROLLBACK;}  \\
\noindent \ttt{select * from public.t;}

\vgap

\noindent What do you see? Why does it happen?

\section{What to Submit}

Each project group should submit a report in the pdf format. The report must contain a separate section for every task. Each section should include
    \myitems{
        \item the necessary screenshots to demonstrate how the corresponding task was carried out;
        \item convincing explanations for your answers to the questions asked in this document. As much as possible, relate your explanations to our lecture slides and base your explanations on hard evidence from the query plan details.
    }
In addition, the report must include a declaration about each group member's contributions, including a contribution percentage for each member (e.g., if your group has 5 members and everyone has contributed equally, you should put down 20\% for each person).

\vgap

One submission per group is sufficient. The submission deadline is \red{\bf 11:59pm, 20 Nov, 2025}.


\end{document}
