\documentclass{beamer}
%\usepackage[dvipsnames]{xcolor}


\usetheme{Warsaw}
%\usetheme{CambridgeUS}

\input{./def/yf-beamer.tex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[skins,breakable]{tcolorbox}

\def\done{\hfill$\square$}
\def\ttt{\texttt}
\def\vgap{\vspace{5mm}}

\newcommand{\dblog}[1]{$<$#1$>$}

\def\abt{\ttt{ABORT}}
\def\best{\mit{best}}
\def\cmt{\ttt{COMMIT}}
\def\iddel{ID_\mit{del}}
\def\idins{ID_\mit{ins}}
\def\inp{\ttt{INPUT}}
\def\ins{\ttt{INSERT}}
\def\out{\ttt{OUTPUT}}
\def\rd{\ttt{READ}}
\def\size{\mit{size}}
\def\slock{\ttt{S-LOCK}}
\def\sort{\mit{sort}}
\def\upg{\ttt{UPGRADE}}
\def\ulock{\ttt{U-LOCK}}
\def\unlock{\ttt{UNLOCK}}
\def\wt{\ttt{WRITE}}
\def\xlock{\ttt{X-LOCK}}

\title[DATABASE SYSTEM PRINCIPLES]{Transactions 7:\\ Checkpointing}

\author[Yufei Tao @ NTU]{Yufei Tao}
\institute[]{\url{https://www.cse.cuhk.edu.hk/~taoyf}}
\date{}

% \def\dtm{\mathit{d\mbox{-}tm}}
% \def\ftm{\mathit{f\mbox{-}tm}}
\def\bestext{\mathit{best\mbox{-}ext}}

\begin{document}
%-------------------------------------------------------------
\begin{frame}
    \titlepage
%     \begin{tcolorbox}[arc=0mm, colframe=green!50!black, colback=green!10!white] 
%     \end{tcolorbox}
\end{frame}
%-------------------------------------------------------------
\begin{frame}
\begin{small}

    \vgap

    The recovery methods discussed so far have a drawback: \bred{the log grows indefinitely with time}! When the log gets excessively long, recovery becomes exceedingly expensive. This lecture will introduce the \blue{checkpoint technique} to deal with the issue.

    \vgap

    \cbox{blue}{
        We will assume that \bred{undo/redo logging} is applied.
    }

\end{small}
\end{frame}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Checkpointing}

    %\vgap
    \cbox{blue}{
        \blue{Rationale:}
        Write everything to the disk now.
    }

    Specifically, the \blue{checkpoint process} performs the following steps:
    \myenums{
        \item Write to the disk a log record \red{\dblog{START CKPT $(T_1, ..., T_k)$}} where $\red{T_1, ..., T_k}$ are the IDs of the transactions currently \blue{active} (i.e., running at the moment).

        \item Write every global memory copy to its corresponding disk copy.

        \item Write to the disk a log record \red{\dblog{END CKPT}}.
    }

    \cbox{blue}{
        \blue{Note:} The checkpoint process is \blue{non-quiescent}, namely, transactions are running in the meantime.
    }
}
%-------------------------------------------------------------
{
%\setbeamercolor{background canvas}{bg=green}
\myfrm{
%\cbox{green}{
\begin{scriptsize}
        \blue{Example 1:} \vspace{-5mm}

        \begin{center}
        \begin{tabular}{c|c|c|c|c|c|c|c}
             & & \multicolumn{5}{|c|}{value of $A$} \\
            step & schedule & disk & global & $T_1$ & $T_2$ & $T_3$ & log\\
            \hline
            & & 10 & n/a & n/a & n/a & n/a & \dblog{START $T_1$}\\
            1& $\inp(A)$ & 10 & 10 & n/a & n/a & n/a & \\
            2& $T_1: \rd(A)$ & 10 & 10 & 10 & n/a & n/a & \\
            3& $T_1: A = A + 1$ & 10 & 10 & 11 & n/a & n/a & \\
            &&&&& & & \dblog{START $T_2$}\\
            4& $T_1: \wt(A)$ & 10 & 11 & 11 & n/a & n/a & \dblog{$T_1, A, 10, 11$} \\
            5& $T_1: \cmt$ & 10 & 11 & n/a & n/a & n/a & \dblog{COMMIT $T_1$} \\
            6& $T_2: \rd(A)$ & 10 & 11 & n/a & 11 & n/a & \\
            7& $T_2: A = A + 1$ & 10 & 11 & n/a & 12 & n/a & \\
            8& $T_2: \wt(A)$ & 10 & 12 & n/a & 12 & n/a & \dblog{$T_2, A, 11, 12$} \\
            9& \red{chkpt starts} & 10 & 12 & n/a & 12 & n/a & \dblog{START CKPT $(T_2)$} \\
            &  &&&& & & \dblog{START $T_3$}\\
            10& \red{chkpt done} & 12 & 13 & n/a & n/a & n/a & \dblog{END CKPT}\\
            11& $T_2: \cmt$ & 10 & 12 & n/a & n/a & n/a & \dblog{COMMIT $T_2$} \\
            12& $\red{\out(A)}$ & \red{12} & 12 & n/a & n/a & n/a & \\
            13& $T_3: \rd(A)$ & 12 & 12 & n/a & n/a & 12 & \\
            14& $T_3: A = A + 1$ & 12 & 12 & n/a & n/a & 13 & \\
            15& $T_3: \wt(A)$ & 12 & 13 & n/a & n/a & 13 & \dblog{$T_3, A, 12, 13$}\\
            16& $T_3: \cmt$ & 12 & 13 & n/a & n/a & n/a & \dblog{COMMIT $T_3$}\\
            17& $\out(A)$ & 13 & 13 & n/a & n/a & n/a &
        \end{tabular}
        \end{center}

        \cbox{green}{
            The instructions in \bred{red} are generated by the checkpoint process.
        }
\end{scriptsize}
%    }
%}
}
%-------------------------------------------------------------
\myfrm{
\begin{scriptsize}

    \xmybox{Recovery}

    For simplicity, we assume that only one checkpoint exists.

    \vgap

%    \cbox{blue}{
        \blue{Recovery algorithm:}
        \myenums{
            \item \blue{If} \dblog{END CKPT} is absent, apply the ``conventional'' recovery strategy.
            \item \blue{Else} find the \dblog{Start CKPT $(\red{L})$} record --- referred to as the \blue{ST-CKPT} record --- where $\red{L}$ is a set of transactions.
            \item Identify the transactions that committed after the ST-CKPT record, and those that were running at the moment of crash.
            \item Perform a \blue{redo-phase}: Scan the log \red{forward} from the ST-CKPT record. For every \red{\dblog{$T, A, a_{old}, a_{new}$}}, if $T$ had committed after the ST-CKPT record, set the disk copy of $A$ to $a_{new}$.
            \item Perform \blue{undo-phase 1}: Scan the log \red{backward} till the ST-CKPT record. For every \red{\dblog{$T, A, a_{old}, a_{new}$}}, if $T$ did not commit before the crash, set the disk copy of $A$ to $a_{old}$.
            \item Perform \blue{undo-phase 2}: Scan the log \red{backward} from the ST-CKPT record. For every \red{\dblog{$T, A, a_{old}, a_{new}$}}, if $\red{T \in L}$ and it did not commit before the crash, set the disk copy of $A$ to $a_{old}$.
        }

        \cbox{blue}{
            \blue{Think:} Does undo-phase 2 need to scan till the beginning of the log?
        }
 %   }

\end{scriptsize}
}
%-------------------------------------------------------------
\myfrm{
\cbox{green}{
\begin{scriptsize}
        \blue{Example 2:} Assume that the system sees the following log after a system crash.

        \begin{center}
        \begin{tabular}{c|c}
            record \# & log\\
            \hline
            1&\dblog{START $T_1$}\\
            2&\dblog{START $T_2$}\\
            3&\dblog{$T_1, A, 10, 11$} \\
            4&\dblog{COMMIT $T_1$} \\
            5&\dblog{$T_2, A, 11, 12$} \\
            6&\dblog{START CKPT $(T_2)$} \\
            7&\dblog{START $T_3$}%\\
            %\dblog{COMMIT $T_2$} %\\
%             \dblog{END CKPT}\\
%             \dblog{$T_3, A, 12, 13$}\\

            %\dblog{COMMIT $T_3$}
        \end{tabular}
        \end{center}

        The crash happened during the checkpoint process because \dblog{END CKPT} is missing. We apply the same recovery strategy as if there was no checkpointing.

\end{scriptsize}
%    }
}
}
%-------------------------------------------------------------
\myfrm{
\cbox{green}{
\begin{scriptsize}
        \blue{Example 2 (cont.):} Log after a system crash: \vspace{-3mm}

        \begin{center}
        \begin{tabular}{c|c}
            record \# & log\\
            \hline
            1&\dblog{START $T_1$}\\
            2&\dblog{START $T_2$}\\
            3&\dblog{$T_1, A, 10, 11$} \\
            4&\dblog{COMMIT $T_1$} \\
            5&\dblog{$T_2, A, 11, 12$} \\
            6&\dblog{START CKPT $(T_2)$} \\
            7&\dblog{START $T_3$} \\
            8&\dblog{END CKPT}\\
            9&\dblog{COMMIT $T_2$} \\
            10&\dblog{$T_3, A, 12, 13$}\\
            11&\dblog{COMMIT $T_3$}
        \end{tabular}
        \end{center}

        The re-do phase scans records 7-11 and sets the disk copy of $A$ to 13. \\
        No undo-phases 1 and 2 (\blue{think:} why?).

\end{scriptsize}
%    }
}
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
    \begin{scriptsize}
            \blue{Example 2 (cont.):} Log after a system crash: \vspace{-3mm}

            \begin{center}
            \begin{tabular}{c|c}
            record \# & log\\
            \hline
            1&\dblog{START $T_1$}\\
            2&\dblog{START $T_2$}\\
            3&\dblog{$T_1, A, 10, 11$} \\
            4&\dblog{COMMIT $T_1$} \\
            5&\dblog{$T_2, A, 11, 12$} \\
            6&\dblog{START CKPT $(T_2)$} \\
            7&\dblog{START $T_3$} \\
            8&\dblog{END CKPT}\\
            9&\dblog{COMMIT $T_2$} \\
            10&\dblog{$T_3, A, 12, 13$}
        \end{tabular}
            \end{center}

            The re-do phase scans records 7-10 and does not modify the disk. \\
            Undo-phase 1 scans from record 10 back to record 7 and sets the disk copy of $A$ to 12. \\
            No undo-phase 2 (\blue{think:} why?).

    \end{scriptsize}
    %    }
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
    \begin{scriptsize}
            \blue{Example 2 (cont.):} Log after a system crash: \vspace{-3mm}

            \begin{center}
            \begin{tabular}{c|c}
                record \# & log\\
                \hline
                \dblog{START $T_1$}\\
                \dblog{START $T_2$}\\
                \dblog{$T_1, A, 10, 11$} \\
                \dblog{COMMIT $T_1$} \\
                \dblog{$T_2, A, 11, 12$} \\
                \dblog{START CKPT $(T_2)$} \\
                \dblog{START $T_3$}\\
                \dblog{END CKPT}%\\
%                 \dblog{COMMIT $T_2$} \\
%                 \dblog{$T_3, A, 12, 13$}%\\
            \end{tabular}
            \end{center}

            The re-do phase does not nothing. \\
            Undo-phase 1 does not modify the disk. \\
            Undo-phase 2 sets the disk copy of $A$ to 11.

    \end{scriptsize}
    %    }
    }
}
%-------------------------------------------------------------
\end{document} 



