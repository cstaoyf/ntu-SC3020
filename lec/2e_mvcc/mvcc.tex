\documentclass{beamer}

\usetheme{Warsaw}
%\usetheme{CambridgeUS}

\input{./def/yf-beamer.tex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[skins,breakable]{tcolorbox}

\def\done{\hfill$\square$}
\def\ttt{\texttt}
\def\vgap{\vspace{5mm}}

\def\abt{\ttt{ABORT}}
\def\best{\mit{best}}
\def\cmt{\ttt{COMMIT}}
\def\iddel{ID_\mit{mod}}
\def\idins{ID_\mit{ins}}
\def\ins{\ttt{INSERT}}
\def\rd{\ttt{READ}}
\def\size{\mit{size}}
\def\slock{\ttt{S-LOCK}}
\def\sort{\mit{sort}}
\def\upg{\ttt{UPGRADE}}
\def\ulock{\ttt{U-LOCK}}
\def\unlock{\ttt{UNLOCK}}
\def\wt{\ttt{WRITE}}
\def\xlock{\ttt{LOCK}}

\title[DATABASE SYSTEM PRINCIPLES]{Transactions 5:\\ Multi-Version Concurrency Control}

\author[Yufei Tao @ NTU]{Yufei Tao}
\institute[]{\url{https://www.cse.cuhk.edu.hk/~taoyf}}
\date{}

% \def\dtm{\mathit{d\mbox{-}tm}}
% \def\ftm{\mathit{f\mbox{-}tm}}
\def\bestext{\mathit{best\mbox{-}ext}}

\begin{document}
%-------------------------------------------------------------
\begin{frame}
    \titlepage
%     \begin{tcolorbox}[arc=0mm, colframe=green!50!black, colback=green!10!white] 
%     \end{tcolorbox}
\end{frame}
%-------------------------------------------------------------
\begin{frame}
\begin{small}
    Today, we will discuss how to enforce the \bred{read committed} isolation level with \blue{multi-version concurrency control} (MVCC).

    \vgap

    \cbox{blue}{
        Recall that the serializable isolation level should be enforced for critical transactions. For non-critical transactions (e.g., browsing books in a library), the read committed isolation level may suffice. In fact, this is the default isolation level in PostgreSQL and ORACLE (both are well-known database systems).
    }

    %\vgap


\end{small}    
\end{frame}
%-------------------------------------------------------------
\myfrm{

    %Our discussion will focus on the main ideas behind PostgreSQL's MVCC implementation, rather than its full details. To make this easier, we will work under the following assumption:


    We will introduce an assumption:

    \vgap

    \cbox{red}{
        \bred{Assumption:} \\
        Tuples can be inserted and updated but never deleted.
    }

    \vgap

    The assumption allows us to simplify the discussion and concentrate on the core principles behind MVCC's support for ``read committed''. It is not difficult to remove the assumption once those principles are clear, as will be briefly explained at the end of this lecture.

    \vgap


    The protocol we will learn is close to what is implemented in PostgreSQL.
}
%-------------------------------------------------------------
\myfrm{
    \cbox{blue}{
        Each transaction is assigned a unique \blue{ID}.
    }

    \vgap

    \cbox{red}{
        \bred{Remark:} PostgreSQL has the requirement that if a transaction $\red{T_1}$ starts before another transaction $\red{T_2}$, the ID of $T_1$ is smaller than that of $T_2$. We do not need this requirement today.
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Multi-Versioning}

    %\vgap

    \cbox{blue}{
        For each tuple $\red{t}$, the database stores a \blue{history}, which is a sequence of \blue{records} $\red{r_1}, \red{r_2}, ..., \red{r_\ell}$ for some $\red{\ell} \ge 1$ such that:
        \myitems{
            \item each $\red{r_i}$ ($1 \le \red{i} \le \ell$) has the form $(\red{v}, \red{\idins}, \red{\iddel})$, where
            \myitems{
                \item $v$ is a version of $t$ that ever existed;
                \item $\idins$ is the ID of the transaction that created $v$;
                \item $\iddel$ is the ID of the transaction that modified $v$ or \ttt{\red{NULL}} if $i = \ell$;
            }

            \item $r_{i+1}.\idins = r_i.\iddel$ for every $\red{i} \in [1, \ell - 1]$.
        }
    }

    \cbox{green}{
        %\blue{Invariant 1:} $r_\ell.\iddel = \ttt{NULL}$.

        \blue{Invariants:}
        \myitems{
            \item The transactions with IDs $r_1.\idins$, $r_2.\idins$, ..., $r_{\red{\ell-1}}.\idins$ must have committed.
            \item The transaction with ID $r_{\red{\ell}}.\idins$ is either running or has committed (i.e., it cannot be an aborted transaction).
        }
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Multi-Versioning}

    %\vgap

    \cbox{green}{
        \blue{Example 1:} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, \ttt{NULL}).
        \end{center}

        This indicates:
        \myitems{
            \item $t$ was first inserted as $(x_1, y_1)$ by transaction (with ID) 100.
            \item $t$ was then modified to $(x_2, y_2)$ by transaction 103.
            \item $t$ was then modified again to $(x_3, y_3)$ by transaction 110, and this is the current version.
        }

        By the invariant, transactions 100 and 103 must have committed.
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

   %\vgap

    \cbox{blue}{
        \blue{Rule 1:} Reads are always granted (no locks required).
    }

    \cbox{blue}{
        \blue{Rule 2:} Let $\red{t}$ be a tuple and $\red{T}$ be a transaction with id $\red{ID_T}$. Suppose that $T$ performs $\red{\rd(t)}$, and the current history of $t$ is $\red{r_1}, \red{r_2}, ..., \red{r_\ell}$. The database acts as follows:
        \myitems{
            \item \blue{if} $\red{r_\ell.\idins = ID_T}$, then return $r_\ell.v$;
%             \item \blue{elseif} \bred{$r_\ell.\iddel \ne \ttt{NULL}$}, then return nothing;
%             \item \blue{elseif} \bred{the transaction with ID $r_\ell.\idins$ has committed}, then return $r_\ell.v$;
%             \item \blue{elseif} \bred{$\ell \ge 2$}, then return $r_{\red{\ell-1}}.v$;
%             \item \blue{else} return nothing.
            \item \blue{else} return the \bred{last committed version} of $t$.
        }
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

    \cbox{green}{
        \blue{Example 1 (cont.):} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, \ttt{NULL}).
        \end{center}

        \myitems{
            \item If transaction 110 issues $\rd(t)$, it gets $(x_3, y_3)$.
            \item If transaction 109 issues $\rd(t)$ with transaction 110 already committed, it gets $(x_3, y_3)$, i.e., the \bred{last committed version}.
            \item If transaction 109 issues $\rd(t)$ with transaction 110 still running, it gets $(x_2, y_2)$, i.e., the \bred{last committed version}.
        }
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

    \vgap

    \cbox{blue}{
        \blue{Rule 3:} Before a transaction can write to a tuple $\red{t}$, it must be holding a \bred{lock} on $t$.

        \vgap

        To obtain such a lock, a transaction needs to make a \blue{lock request}. The database grants the request if currently there are no locks on $t$. Otherwise, the request is denied, and the transaction is suspended until its request is granted.
    }

}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    \vgap

    \cbox{blue}{
        \blue{Rule 4:} Let $\red{T}$ be a transaction with id $\red{ID_T}$ that holds a lock on a tuple $\red{t}$. Suppose that $T$ performs $\red{\wt(t, v_{new})}$ --- namely, setting the tuple $t$ to $v_{new}$. The database acts as follows:
        \myitems{
            \item If $t$ is new (i.e., no history), create a history of $t$ with only one record $\red{(v_{new}, ID_T, \ttt{NULL})}$.
            \item Otherwise, let $\red{r_1}, \red{r_2}, ..., \red{r_\ell}$ be the \bred{current} history of $t$.
            \myitems{
                \item \blue{If} $r_\ell.\idins = ID_T$, then set $r_\ell.v = v_{new}$, i.e., replacing the last record.
                \item \blue{Else}, set $r_\ell.\iddel = ID_T$ and append a new record $(v_{new}, ID_T, \ttt{NULL})$ to the history.
            }


        }
        %, and
    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

    \cbox{green}{
        \blue{Example 1 (cont.):} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, \ttt{NULL}).
        \end{center}

        If transaction 110 modifies $t$ to $(x_4, y_4)$, the history becomes
            \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_4, y_4$), 110, \ttt{NULL}).
        \end{center}

    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

    \cbox{green}{
        \blue{Example 1 (cont.):} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, \ttt{NULL}).
        \end{center}

        Suppose that transaction 111 modifies $t$ to $(x_4, y_4)$ after transaction 110 has committed. The history becomes
            \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, 111) \\
             (($x_4, y_4$), 111, \ttt{NULL}).
        \end{center}

    }
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

   \vgap

    \cbox{blue}{
        \blue{Rule 5:} A transaction releases all locks after having committed or aborted.
    }

}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Concurrency Control}

    %\vgap

    \vgap

    If a transaction aborts, its changes to the history are canceled.

    \vgap

    \cbox{green}{
        \blue{Example 1 (cont.):} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, \ttt{NULL}).
        \end{center}

        If transaction 110 aborts, the history becomes
            \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, \ttt{NULL}) .
        \end{center}

    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2:} Let $\red{t}$ be a tuple of relation $\red{R(A)}$ whose history has a single record $(10, 100, \ttt{NULL})$. Transaction 100 has committed. Transactions $\red{T_1}$, $\red{T_2}$, and $\red{T_3}$ have IDs 101, 102, and 103, respectively. Assume that the database attempts to execute the instructions of $T_1$ and $T_2$ in the order shown below.

        \begin{center}
        \begin{tabular}{c|c|c|c}
            &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
            \hline
            1& \rd($t$) & & \\
            2& & $\xlock(t)$ & \\
            3& & \wt($t$, \red{20}) & \\
            4& & & $\xlock(t)$ \\
            5& & & \wt($t$, \red{30}) \\
            6& $\rd(t)$ & \\
            7& & \rd$(t)$ \\
            8& & \cmt \\
            9&&&\cmt \\
            10& $\rd(t)$ & \\
            11&\cmt&
        \end{tabular}
        \end{center}

        We will walk through the execution in the next few slides.
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
        \begin{center}
        \begin{tabular}{c|c|c|c}
            &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
            \hline
            $\red{\bm{\rightarrow}}$ 1& \rd($t$) & & \\
            2& & $\xlock(t)$ & \\
            3& & \wt($t$, \red{20}) & \\
            4& & & $\xlock(t)$ \\
            5& & & \wt($t$, \red{30}) \\
            6& $\rd(t)$ & \\
            7& & \rd$(t)$ \\
            8& & \cmt \\
            9&&&\cmt \\
            10& $\rd(t)$ & \\
            11&\cmt&
        \end{tabular}
        \end{center}

        History of $t$: $(10, 100, \ttt{NULL})$. \\

        $T_1$ reads $t = 10$ (Rules 1, 2).
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
        \begin{center}
        \begin{tabular}{c|c|c|c}
            &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
            \hline
            $\red{\bm{\rightarrow}}$ 2& & $\xlock(t)$ & \\
            3& & \wt($t$, \red{20}) & \\
            4& & & $\xlock(t)$ \\
            5& & & \wt($t$, \red{30}) \\
            6& $\rd(t)$ & \\
            7& & \rd$(t)$ \\
            8& & \cmt \\
            9&&&\cmt \\
            10& $\rd(t)$ & \\
            11&\cmt&
        \end{tabular}
        \end{center}

        Granted (Rule 3).
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}

\begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
    $\red{\bm{\rightarrow}}$ 3& & \wt($t$, \red{20}) & \\
    4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
    6& $\rd(t)$ & \\
    7& & \rd$(t)$ \\
    8& & \cmt \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        By Rule 4, the history of $t$ now has two records: \\
        $(10, 100, 102)$, $(20,102, \ttt{NULL})$.
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}

        \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
    $\red{\bm{\rightarrow}}$ 4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
    6& $\rd(t)$ & \\
    7& & \rd$(t)$ \\
    8& & \cmt \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        Denied (Rule 3) and $T_3$ is suspended.
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}

        \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
    4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
    $\red{\bm{\rightarrow}}$ 6& $\rd(t)$ & \\
    7& & \rd$(t)$ \\
    8& & \cmt \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}


        History of $t$:
        $(10, 100, 102)$, $(20,102, \ttt{NULL})$. \\

        $T_1$ reads $t = 10$ (Rules 1, 2), noticing that the trans.\ with ID 102 (i.e., $T_2$) is still running.
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
    4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
$\red{\bm{\rightarrow}}$    7& & \rd$(t)$ \\
    8& & \cmt \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        History of $t$:
        $(10, 100, 102)$, $(20,102, \ttt{NULL})$. \\

        $T_2$ reads $t = 20$ (Rules 1, 2).
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
    4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
$\red{\bm{\rightarrow}}$    8& & \cmt \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        History of $t$:
        $(10, 100, 102)$, $(20,102, \ttt{NULL})$. \\

        $T_2$ commits and releases the lock on $t$ (Rule 5).
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
$\red{\bm{\rightarrow}}$    4& & & $\xlock(t)$ \\
    5& & & \wt($t$, \red{30}) \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        History of $t$:
        $(10, 100, 102)$, $(20,102, \ttt{NULL})$. \\

        $T_3$ now resumes and holds the lock on $t$ (Rule 3).
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
$\red{\bm{\rightarrow}}$
    5& & & \wt($t$, \red{30}) \\
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        By Rule 4, the history of $t$ becomes \\
        $(10, 100, 102)$, $(20,102, 103)$, $(30,103, \ttt{NULL})$.
    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
$\red{\bm{\rightarrow}}$
    9&&&\cmt \\
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        History of $t$:
        $(10, 100, 102)$, $(20,102, 103)$, $(30,103, \ttt{NULL})$. \\

                $T_3$ commits and releases the lock on $t$ (Rule 5).

    }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{green}{
        \blue{Example 2 (cont.)}
         \begin{center}
\begin{tabular}{c|c|c|c}
    &$\red{T_1}$ ID 101 & $\red{T_2}$ ID 102 & $\red{T_3}$ ID 103\\
    \hline
$\red{\bm{\rightarrow}}$
    10& $\rd(t)$ & \\
    11&\cmt&
\end{tabular}
\end{center}

        History of $t$:
        $(10, 100, 102)$, $(20,102, 103)$, $(30,103, \ttt{NULL})$. \\

        $T_1$ reads $t = 30$ (Rules 1, 2).


    }
}
%-------------------------------------------------------------
\myfrm{
     \cbox{blue}{
        \blue{Theorem:} The schedule produced by the protocol we described is  recoverable and enforces the read committed isolation level.
    }

    \vgap

     The theorem holds regardless of how the instructions of different transactions are interleaved.

     \vgap

     \cbox{red}{
        \bred{Remark:} A schedule produced by the protocol may perform non-repeatable reads (see Example 2). Therefore, the protocol does \bred{not} enforce the ``repeatable reads'' isolation level.
     }
}
%-------------------------------------------------------------
\myfrm{
    \cbox{blue}{
        The MVCC protocol we discussed can create deadlocks (\blue{think}: why?).
    }

    \vgap

    The system handles a deadlock by aborting a transaction in the waiting cycle (see the lecture notes ``Two Phase Locking'').
}
%-------------------------------------------------------------
\myfrm{
    \cbox{blue}{
        \blue{Remark:} If the purpose is \bred{only} to enforce the read committed isolation level, it suffices to keep the last two entries of a history at all times.

        \vgap

        However, multi-versioning is useful for many other purposes as well. For instance:
        \myitems{
            \item Implementing other isolation levels (e.g., serializable);
            \item Obtaining the database content at any past timestamp (i.e., a \blue{snapshot}).
        }
        Today, many database systems support multi-versioning.
    }
}
%-------------------------------------------------------------
\myfrm{

    \vgap



    \cbox{yellow}{
        \centering
        The following material will not be tested.
    }

    So far we have assumed no tuple deletions. Next, we will briefly explain how to remove the assumption based on the principles explained earlier.
}
%-------------------------------------------------------------
\myfrm{


    \vgap

    If a tuple is removed, the transaction performing the removal is logged in the last record of the tuple's history.

    \vgap

    \cbox{green}{
        \blue{Example 3:} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, 111).
        \end{center}

        Tuple $t$ has been deleted by transaction 111.
    }
}
%-------------------------------------------------------------
\myfrm{
    When a transaction $\red{T}$ reads a tuple $\red{t}$ that has been deleted by another transaction, $T$ gets the last committed version of $t$.

    \vgap

    \cbox{green}{
        \blue{Example 3 (cont.):} Let $\red{t}$ be a tuple in the relation $R(X, Y)$ with the history:

        \begin{center}
             (($x_1, y_1$), 100, 103) \\
             (($x_2, y_2$), 103, 110) \\
             (($x_3, y_3$), 110, 111).
        \end{center}

        \myitems{
            \item If transaction 111  issues $\rd(t)$, it gets nothing.

            \item If transaction 109 issues $\rd(t)$ with transaction 111 already committed, it gets nothing --- note that ``nothing'' is indeed the \bred{last committed version}.

            \item If transaction 109 issues $\rd(t)$ with transaction 111 still running, it gets $(x_3, y_3)$, i.e., the \bred{last committed version}.
        }
    }
}
%-------------------------------------------------------------
\myfrm{
    \blue{Think:}\\
    How would you extend Rule 4 to support the deletion of a tuple $\red{t}$?
}
%-------------------------------------------------------------
\end{document} 



