\documentclass{beamer}

\usetheme{Warsaw}
%\usetheme{CambridgeUS}

\input{./def/yf-beamer.tex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[skins,breakable]{tcolorbox}

\def\done{\hfill$\square$}
\def\ttt{\texttt}
\def\vgap{\vspace{5mm}}

\def\sort{\mit{sort}}

\title[DATABASE SYSTEM PRINCIPLES]{Query Processing 6:\\ Join Order Optimization}

\author[Yufei Tao @ NTU]{Yufei Tao}
\institute[]{\url{https://www.cse.cuhk.edu.hk/~taoyf}}
\date{}

% \def\dtm{\mathit{d\mbox{-}tm}}
% \def\ftm{\mathit{f\mbox{-}tm}}
\def\bestext{\mathit{best\mbox{-}ext}}

\begin{document}
%-------------------------------------------------------------
\begin{frame}
    \titlepage
%     \begin{tcolorbox}[arc=0mm, colframe=green!50!black, colback=green!10!white] 
%     \end{tcolorbox}
\end{frame}
%-------------------------------------------------------------
\begin{frame}
\begin{small}
    In this lecture, we will discuss the \blue{join order} problem, which is the most important query rewriting optimization in database systems.

    \vgap

    Recall:
    \cbox{blue}{
        \blue{Query rewriting} converts the original query to an equivalent query using laws of relational algebra.
    }
    %\vgap
\end{small}    
\end{frame}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Laws of natural joins}

    \vgap

    Let $\red{R_1}, \red{R_2}$, and $\red{R_3}$ be relations.

    \vgap

    \blue{Commutativity:} $R_1 \bowtie R_2 = R_2 \bowtie R_1$ \\
    \blue{Associativity:} $R_1 \bowtie (R_2 \bowtie R_3) = (R_1 \bowtie R_2) \bowtie R_3$ \\
}
%-------------------------------------------------------------
\myfrm{
    \cbox{blue}{
        Various join orderings can have extremely different I/O costs.
    }

    \cbox{green}{
        \blue{Example:}\\
        Relations $\red{R_1(A,B)}$, $\red{R_2(C,D)}$, $\red{R_3(A,D)}$, each having 1000 tuples, where $A$ is the primary key of $R_1$.

        \vgap

        \blue{Ordering 1:} $R_1 \bowtie R_2 \bowtie R_3$ \\
        The intermediate relation $\red{R_4} = R_1 \bowtie R_2$ has $1000^2 = 10^6$ tuples!

        \vgap

        \blue{Ordering 2:} $R_1 \bowtie R_3 \bowtie R_2$ \\
        The intermediate relation $\red{R_5} = R_1 \bowtie R_3$ has at most $1000$ tuples.

        %\vgap

        \cbox{blue}{
        Ordering 2 is significantly more efficient than ordering 1 --- you can estimate the I/O cost of using, e.g., the sort join algorithm to compute the join under each ordering.}
    }
}
%-------------------------------------------------------------
\myfrm{
    In general, let $\red{R_1}, \red{R_2}, ..., \red{R_k}$ be $\red{k}$ relations.

    \cbox{blue}{
        An \blue{ordering} is a permutation of the $k$ relations.
    }
    Number of orderings $= k!$.

    \vgap

    \cbox{blue}{
        Fix an arbitrary ordering $\red{\pi} = R_{\red{a_1}}$, $R_{\red{a_2}}$, ..., $R_{\red{a_k}}$.
        \myitems{
            \item For each $\red{i} \in [2, k-1]$, the join $\red{R_{a_1} \bowtie R_{a_2} \bowtie ... \bowtie R_{a_i}}$ is a \blue{prefix} of $\pi$. The \blue{capacity} of the prefix is $|R_{a_1} \bowtie R_{a_2} \bowtie ... \bowtie R_{a_i}|$, i.e., the number of tuples in the result of the prefix.

            \item The \blue{capacity} of $\pi$ is the sum of the capacities of all its $k-2$ prefixes.
        }
    }
}
%-------------------------------------------------------------
\end{document} 


