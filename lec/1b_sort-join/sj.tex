\documentclass{beamer}

\usetheme{Warsaw}
%\usetheme{CambridgeUS}

\input{./def/yf-beamer.tex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[skins,breakable]{tcolorbox}

\def\done{\hfill$\square$}
\def\ttt{\texttt}
\def\vgap{\vspace{5mm}}

\title[DATABASE SYSTEM PRINCIPLES]{Query Processing 3:\\ Sort Join}

\author[Yufei Tao @ NTU]{Yufei Tao}
\institute[]{\url{https://www.cse.cuhk.edu.hk/~taoyf}}
\date{}

% \def\dtm{\mathit{d\mbox{-}tm}}
% \def\ftm{\mathit{f\mbox{-}tm}}
\def\bestext{\mathit{best\mbox{-}ext}}

\begin{document}
%-------------------------------------------------------------
\begin{frame}
    \titlepage
%     \begin{tcolorbox}[arc=0mm, colframe=green!50!black, colback=green!10!white] 
%     \end{tcolorbox}
\end{frame}
%-------------------------------------------------------------
\begin{frame}
\begin{small}
    This lecture will introduce the \blue{sort join} algorithm for computing a natural join involving two relations.
    %\vgap
\end{small}    
\end{frame}
%-------------------------------------------------------------
\myfrm{
    \xmybox{The Binary Join Problem}

    \vgap

    $\red{R_1(X, Y)}$: A relation with attributes $X$ and $Y$. \\
    $\red{R_2(X, Z)}$: A relation with attributes $X$ and $Z$. \\
    $\red{B_1} =$ the number of disk blocks that $R_1$ occupies. \\
    $\red{B_2} =$ the number of disk blocks that $R_2$ occupies. \\
    $\red{M} =$ the number of memory blocks (a.k.a., the buffer blocks). \\
    \myitems{
        \item We assume $M \ge 5$.
    }

    \vgap

    \blue{Goal:} Compute the join result $R_1 \bowtie R_2$.

    \vgap

    We will carry out our discussion under another assumption: \\
    \cbox{red}{
        \blue{No skew assumption:} \\
        For any $X$-value, the tuples of $R_1$ having that value fit in at most $M-3$ blocks.
    }

}
%-------------------------------------------------------------
\myfrm{
    %\xmybox{Binary Join}

    \vgap

    \blue{Example}
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join}

    \vgap

    \blue{Step 1:} Sort $R_1(X, Y)$ on $X$, and sort $R_2(X, Z)$ on $X$ \\
    \myitems{
        \item Using the external sort algorithm.
    }
    \blue{Step 2:} Scan the sorted $R_1$ and $R_2$ synchronously to output the result.

    \vgap

    Next, we will explain how to do Step 2 in $B_1 + B_2$ I/Os.
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join: Step 2}

    %\vgap

    We will maintain a value $\red{x_1}$ for $R_1$ and a value $\red{x_2}$ for $R_2$ to enforce the following invariant:

    \cbox{blue}{
        \blue{Invariant:} All the result tuples of $R_1$ (resp., $R_2$) with $X$-values less than $x_1$ (resp., $x_2$) have been output.
    }

    %\vgap

    In the beginning, load the first blocks of $R_1$ and $R_2$ into memory. \\
    Set $x_1$ (resp., $x_2$) to the $X$-value of the first tuple of $R_1$ (resp., $R_2$).

    \begin{center}
        \includegraphics[height=40mm]{./artwork/em-sj1}
    \end{center}

}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join: Step 2}

    \bred{If $x_1 < x_2$}, move $x_1$ to the next element of $R_1$ (loading the next block of $R_1$ into memory if necessary).
    \bred{If $x_2 < x_1$}, move $x_2$ to the next element of $R_2$ (loading the next block of $R_2$ into memory if necessary).

    \vgap

    \begin{center}
        \includegraphics[height=40mm]{./artwork/em-sj2}
    \end{center}
}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join: Step 2}

    \bred{If $x_1 = x_2$}, read into memory all tuples of $R_1$ with $X$-value equal to $x_1$. \\
    By the no-skew assumption, they occupy at most $M-3$ memory blocks.

    %\vgap

    \begin{center}
        \includegraphics[height=40mm]{./artwork/em-sj3}
    \end{center}

}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join: Step 2}

    %\bred{If $x_1 = x_2$}, read into memory all tuples of $R_1$ with $X$-value equal to $x_1$. \\
    %By the no-skew assumption, they occupy at most $M-2$ memory blocks. \\

    Then use one memory block to read every block of $R_2$ containing tuples whose $X$-values equal $x_2$ (one block at a time). For each block read, produce all the result tuples whose $X$-values equal $x_2$.

    %\vgap

    \begin{center}
        \includegraphics[height=40mm]{./artwork/em-sj4}
    \end{center}


}
%-------------------------------------------------------------
\myfrm{
    \xmybox{Sort Join: Step 2}

    Move $x_1$ to the next element of $R_1$ (reading the next block of $R_1$ if necessary). Move $x_2$ to the next element of $R_2$ (reading the next block of $R_2$ if necessary).

    %\vgap

    \begin{center}
        \includegraphics[height=40mm]{./artwork/em-sj5}
    \end{center}

    The algorithm continues in the same fashion until $R_1$ or $R_2$ is exhausted.
}
%-------------------------------------------------------------
\end{document} 
